# FSL Continuum - fsl-initiation
# SPEC:000 - Core Workflows Migration
# Part of FSL Continuum v2.1 - Terminal Velocity CI/CD

# FSL Continuum Initiation with OpenSpec & Cost Estimation
# Kicks off the complete AI engineering loop process

name: FSL Continuum - Loop Initiation

on:
  push:
    branches: [main, develop]
    paths:
      - '.specs/**'
      - 'specs/**'
      - '*.spec'
  pull_request:
    types: [opened, synchronize]
    branches: [main, develop, staging]
  workflow_dispatch:
    inputs:
      spec_mode:
        description: 'OpenSpec mode'
        required: false
        default: 'research'
        type: choice
        options: ['research', 'planning', 'execution']
      estimate_cost:
        description: 'Estimate cost before execution'
        required: false
        default: true
        type: boolean
      parent_tx_hash:
        description: 'Parent EXPChain transaction hash (for context)'
        required: false
        type: string

env:
  FLOW_STATE_VERSION: "2.0"
  EXPCHAIN_NETWORK: "testnet"
  COST_APPROVAL_THRESHOLD: "0.25"

permissions:
  contents: read
  pull-requests: write
  issues: write
  actions: read

jobs:
  # Phase 1: OpenSpec Initiation with Cost Estimation
  initiate-spec:
    runs-on: ubuntu-latest
    outputs:
      spec-hash: ${{ steps.create-spec.outputs.hash }}
      cost-estimate: ${{ steps.estimate-cost.outputs.estimate }}
      context-lineage: ${{ steps.context.outputs.lineage }}
      approval-required: ${{ steps.estimate.outputs.approval-required }}
      
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Setup Python Environment
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install Flow State Dependencies
      run: |
        pip install pygithub jinja2 markdown2 yaml requests
        npm install -g @fission-ai/openspec
        
    - name: Initialize Flow State Context
      id: context
      run: |
        python3 << 'EOF'
        import os
        import json
        import hashlib
        from pathlib import Path
        
        # Determine context lineage
        parent_tx = "${{ github.event.inputs.parent_tx_hash }}"
        if parent_tx:
            context_lineage = [parent_tx]
        else:
            # Check for previous contexts in the branch
            context_lineage = []
            
        # Create context object
        flow_context = {
            "flow_id": hashlib.sha256(f"${{ github.repository }}_${{ github.run_id }}".encode()).hexdigest()[:16],
            "repository": "${{ github.repository }}",
            "pr_number": "${{ github.event.pull_request.number || '0' }}",
            "branch": "${{ github.head_ref || github.ref_name }}",
            "commit": "${{ github.sha }}",
            "actor": "${{ github.actor }}",
            "parent_tx": parent_tx,
            "context_lineage": context_lineage,
            "timestamp": "${{ github.run_number }}",
            "mode": "${{ github.event.inputs.spec_mode || 'research' }}"
        }
        
        # Save context file
        Path('.flow-state').mkdir(exist_ok=True)
        with open('.flow-state/context.json', 'w') as f:
            json.dump(flow_context, f, indent=2)
        
        # Set outputs
        print(f"lineage={json.dumps(context_lineage)}")
        print(f"flow_id={flow_context['flow_id']}")
        EOF
        
    - name: Parse Natural Language to Structured Spec
      id: create-spec
      run: |
        python3 << 'EOF'
        import os
        import json
        from pathlib import Path
        
        # Load flow context
        with open('.flow-state/context.json') as f:
            context = json.load(f)
        
        # Extract PR information or create base spec
        spec_data = {
            "flow_id": context["flow_id"],
            "repository": context["repository"],
            "title": "${{ github.event.pull_request.title || 'Flow State Initiation' }}",
            "description": "${{ github.event.pull_request.body || 'Initiating FSL Continuum for engineering process automation' }}",
            "author": context["actor"],
            "branch": context["branch"],
            "pr_number": context["pr_number"],
            "mode": context["mode"],
            "timestamp": context["timestamp"]
        }
        
        # Generate structured JSON spec
        if context["pr_number"] != "0":
            # PR-based spec
            spec_data["spec_type"] = "pr_enhancement"
            spec_data["requirements"] = [
                "Analyze PR changes and context",
                "Generate technical specification",
                "Create implementation plan",
                "Estimate resource requirements"
            ]
        else:
            # Branch-based spec
            spec_data["spec_type"] = "feature_development"
            spec_data["requirements"] = [
                "Define feature requirements",
                "Design implementation approach",
                "Plan testing strategy",
                "Consider performance implications"
            ]
        
        # Add OpenSpec structured format
        structured_spec = {
            "metadata": {
                "version": "1.0",
                "created": context["timestamp"],
                "flow_id": context["flow_id"],
                "repository": context["repository"]
            },
            "specification": {
                "title": spec_data["title"],
                "description": spec_data["description"],
                "type": spec_data["spec_type"],
                "requirements": spec_data["requirements"],
                "context": {
                    "branch": spec_data["branch"],
                    "pr_number": spec_data["pr_number"],
                    "author": spec_data["author"]
                }
            },
            "technical_details": {
                "architecture": "TBD",
                "dependencies": [],
                "implementation_phases": [],
                "testing_strategy": "comprehensive",
                "security_considerations": ["standard"],
                "performance_targets": "baseline"
            }
        }
        
        # Save structured spec
        spec_path = f'.flow-state/spec-{context["flow_id"]}.json'
        with open(spec_path, 'w') as f:
            json.dump(structured_spec, f, indent=2)
        
        # Calculate spec hash
        import hashlib
        spec_content = json.dumps(structured_spec, sort_keys=True)
        spec_hash = hashlib.sha256(spec_content.encode()).hexdigest()
        
        print(f"hash={spec_hash}")
        print(f"path={spec_path}")
        EOF
        
    - name: Estimate Token Cost & Complexity
      id: estimate-cost
      run: |
        python3 << 'EOF'
        import json
        import os
        
        # Load spec and context
        with open('${{ steps.create-spec.outputs.path }}') as f:
            spec = json.load(f)
        with open('.flow-state/context.json') as f:
            context = json.load(f)
        
        # Cost estimation model
        base_tokens = 1500  # Base context and overhead
        input_tokens = len(json.dumps(spec)) // 4  # Rough character-to-token ratio
        output_tokens = 8000  # Expected code generation output
        complexity_score = 7.5  # Default complexity
        
        # Adjust based on spec type and size
        if spec["specification"]["type"] == "pr_enhancement":
            complexity_score = 5.0  # Lower complexity for PR analysis
            output_tokens = 4000
        elif spec["specification"]["type"] == "feature_development":
            complexity_score = 8.5  # Higher complexity for new features
            output_tokens = 12000
        
        # Calculate cost (using assumed rates)
        # Input: $0.001 per 1K tokens, Output: $0.002 per 1K tokens
        input_cost = (base_tokens + input_tokens) / 1000 * 0.001
        output_cost = output_tokens / 1000 * 0.002
        total_cost = input_cost + output_cost
        
        # Determine if approval needed
        approval_threshold = float(os.environ.get('COST_APPROVAL_THRESHOLD', '0.25'))
        approval_required = total_cost > approval_threshold
        
        cost_estimate = {
            "input_tokens": base_tokens + input_tokens,
            "output_tokens": output_tokens,
            "estimated_cost_usd": round(total_cost, 4),
            "complexity_score": complexity_score,
            "estimated_review_cycles": 2 if complexity_score > 7 else 1,
            "approval_required": approval_required,
            "confidence_score": 0.85
        }
        
        # Save cost estimate
        with open('.flow-state/cost-estimate.json', 'w') as f:
            json.dump(cost_estimate, f, indent=2)
        
        print(f"estimate={json.dumps(cost_estimate)}")
        print(f"approval-required={approval_required}")
        EOF
        
    - name: Request Cost Approval (if needed)
      if: steps.estimate-cost.outputs.approval-required == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          const costEstimate = JSON.parse(`{${{ steps.estimate-cost.outputs.estimate }}}`);
          
          let comment = '## ðŸ’° Cost Approval Required\n\n';
          comment += `This FSL Continuum requires approval due to estimated cost over $${process.env.COST_APPROVAL_THRESHOLD}.\n\n`;
          comment += `| Metric | Value |\n`;
          comment += `|--------|-------|\n`;
          comment += `| Input Tokens | ${costEstimate.input_tokens} |\n`;
          comment += `| Output Tokens | ${costEstimate.output_tokens} |\n`;
          comment += `| Estimated Cost | $${costEstimate.estimated_cost_usd} |\n`;
          comment += `| Complexity | ${costEstimate.complexity_score}/10 |\n`;
          comment += `| Review Cycles | ${costEstimate.estimated_review_cycles} |\n\n`;
          comment += '### Approve to Continue\n\n';
          comment += `To approve this FSL Continuum, comment:\n\`/approve-flow ${{ steps.context.outputs.flow_id }}\`\n\n`;
          comment += 'The loop will proceed after approval.\n\n';
          comment += 'ðŸ¤– *Cost estimation powered by FSL Continuum v2.0*';
          
          await github.rest.issues.createComment({
            issue_number: context.issue.number || (await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              creator: context.actor,
              state: 'open'
            })).data[0].number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });
          
    - name: Wait for Approval
      if: steps.estimate-cost.outputs.approval-required == 'true'
      run: |
        echo "Waiting for approval comment..."
        # In a real implementation, this would poll for approval comment
        # For now, simulate approval after 60 seconds
        sleep 60
        
    - name: Upload Flow State Artifacts
      uses: actions/upload-artifact@v3
      with:
        name: fsl-${{ steps.create-spec.outputs.hash }}
        path: |
          .flow-state/
        retention-days: 30

  # Phase 2: EXPChain Transaction Commit (if approved)
  commit-to-expchain:
    runs-on: ubuntu-latest
    needs: initiate-spec
    if: needs.initiate-spec.outputs.approval-required == 'false' || always()
    
    steps:
    - name: Setup EXPChain CLI
      run: |
        # Install EXPChain CLI (mock for demo)
        echo "Installing EXPChain CLI..."
        mkdir -p ~/.expchain
        echo '{"network": "testnet", "api_url": "https://expchain-testnet.api.example.com"}' > ~/.expchain/config.json
        
    - name: Commit Spec Transaction
      id: commit-tx
      run: |
        python3 << 'EOF'
        import json
        import hashlib
        import os
        import requests
        from pathlib import Path
        
        # Load flow state data
        with open('.flow-state/spec-${{ needs.initiate-spec.outputs.spec-hash }}.json') as f:
            spec = json.load(f)
        with open('.flow-state/cost-estimate.json') as f:
            cost = json.load(f)
        with open('.flow-state/context.json') as f:
            context = json.load(f)
        
        # Create symbolic residue
        symbolic_residue = {
            "flow_id": context["flow_id"],
            "timestamp": context["timestamp"],
            "parent_context": context["parent_tx"],
            "context_lineage": context["context_lineage"],
            "estimated_complexity": cost["complexity_score"],
            "approval_granted": not cost["approval_required"],
            "mode": context["mode"]
        }
        
        # Create EXPChain transaction
        transaction = {
            "type": "SPEC_INIT",
            "spec_hash": "${{ needs.initiate-spec.outputs.spec-hash }}",
            "parent_tx": context["parent_tx"],
            "symbolic_residue": symbolic_residue,
            "cost_estimate": cost,
            "context_proof": {
                "available_context": [],
                "utilized_context": [],
                "context_quality_score": 0.85
            },
            "repository": context["repository"],
            "branch": context["branch"]
        }
        
        # Submit to EXPChain (mock implementation)
        tx_hash = hashlib.sha256(json.dumps(transaction, sort_keys=True).encode()).hexdigest()
        print(f"Transaction submitted: {tx_hash}")
        
        # Update context with transaction hash
        context["expchain_tx"] = tx_hash
        with open('.flow-state/context.json', 'w') as f:
            json.dump(context, f, indent=2)
        
        print(f"tx_hash={tx_hash}")
        EOF
        
    - name: Update PR with Transaction Link
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: `## ðŸ”— Flow State Transaction\n\n**EXPChain TX**: \`#${{ steps.commit-tx.outputs.tx_hash }}\`\n\n**Explorer**: [View Transaction](https://expchain.explorer/tx/${{ steps.commit-tx.outputs.tx_hash }})\n\n**Symbolic Residue**: Includes context lineage, complexity score, and approval status.\n\nThe flow state has been committed to the blockchain.ä¸‹ä¸€æ­¥: Issue decomposition.`
          });

  # Phase 3: Trigger Issue Decomposition
  trigger-decomposition:
    runs-on: ubuntu-latest
    needs: [initiate-spec, commit-to-expchain]
    if: needs.commit-to-expchain.result == 'success'
    
    steps:
    - name: Trigger Decomposition Workflow
      run: |
        python3 << 'EOF'
        import json
        import requests
        import os
        
        # Load context
        with open('.flow-state/context.json') as f:
            context = json.load(f)
        
        # Trigger next workflow
        workflow_trigger = {
            "event_name": "workflow_dispatch",
            "repository": context["repository"],
          workflow: "fsl-decomposition.yml",
          "inputs": {
            "spec_file": f'.flow-state/spec-{context["flow_id"]}.json',
            "parent_tx": context["expchain_tx"],
            "flow_id": context["flow_id"]
          }
        }
        
        print("Triggering issue decomposition workflow...")
        print(f"Flow ID: {context['flow_id']}")
        print(f"Parent TX: {context['expchain_tx']}")
        EOF
        
    - name: Update Status
      run: |
        echo "âœ… FSL Continuum Phase 1 Complete"
        echo "ðŸ“‹ Spec created and committed to EXPChain"
        echo "ðŸ”— Transaction hash: ${{ steps.commit-tx.outputs.tx_hash }}"
        echo "ðŸ“Œ Next phase: Issue decomposition with context lineage"

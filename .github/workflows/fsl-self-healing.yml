# FSL Continuum - fsl-self-healing
# SPEC:000 - Core Workflows Migration
# Part of FSL Continuum v2.1 - Terminal Velocity CI/CD

# Autonomous Self-Healing Workflows with AI Monitoring
# Real-time anomaly detection, automated remediation, continuous optimization

name: Self-Healing Automation

on:
  workflow_run:
    workflows:
      - "fsl-execution"
      - "fsl-security"
      - "fsl-merger"
    types:
      - completed
  workflow_dispatch:
    inputs:
      healing_mode:
        description: 'Type of healing to perform'
        required: false
        default: 'automated'
        type: choice
        options: ['automated', 'manual', 'preventive']
      target_area:
        description: 'Area to focus healing on'
        required: false
        default: 'all'
        type: choice
        options: ['all', 'infrastructure', 'dependencies', 'security', 'performance', 'costs']

env:
  HEALING_THRESHOLD: "0.8"
  ANOMALY_DETECTION_MODEL: "self_healing_v1"
  AUTO_RECOVERY_TIMEOUT: "1800"
  LEARNING_RATE: "0.1"

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: read

jobs:
  # Phase 1: Continuous Health Monitoring
  health-monitoring:
    runs-on: ubuntu-latest
    outputs:
      health_score: ${{ steps.monitor.outputs.health-score }}
      anomalies_detected: ${{ steps.monitor.outputs.anomalies }}
      
    steps:
    - name: System Health Assessment
      id: monitor
      run: |
        python3 << 'EOF'
        import json
        import os
        import time
        import subprocess
        from datetime import datetime, timedelta
        from pathlib import Path
        
        print("üè• Initializing Self-Healing Health Monitor...")
        
        # Create healing metrics directory
        os.makedirs('.flow-state/healing', exist_ok=True)
        os.makedirs('.flow-state/healing/metrics', exist_ok=True)
        
        # Gather system health metrics
        health_metrics = {
            "timestamp": datetime.now().isoformat(),
            "workflow_run_id": "${{ github.run_id }}",
            "health_checks": {}
        }
        
        # Check FSL Continuum specific health
        flow_checks = {
            "flow_state_consistency": check_flow_state_consistency(),
            "transaction_integrity": check_transaction_integrity(),
            "context_lineage_health": check_context_lineage(),
            "knowledge_graph_connectivity": check_kg_connectivity(),
            "resource_utilization": get_resource_metrics(),
            "dependency_health": check_dependency_health()
        }
        
        # Add flow_state checks to health metrics
        health_metrics["health_checks"] = flow_checks
        
        # Detect anomalies using historical patterns
        anomalies = detect_anomalies(flow_checks)
        
        # Calculate overall health score
        health_score = calculate_health_score(flow_checks, anomalies)
        
        # Save current health state
        health_metrics["anomalies"] = anomalies
        health_metrics["health_score"] = health_score
        health_metrics["healing_needed"] = health_score < float('${{ env.HEALING_THRESHOLD }}')
        health_metrics["anomaly_count"] = len(anomalies)
        
        with open('.flow-state/healing/health-${{ github.run_id }}.json', 'w') as f:
            json.dump(health_metrics, f, indent=2)
        
        # Store in metrics history
        metrics_history = load_metrics_history()
        metrics_history.append(health_metrics)
        
        # Keep last 1000 metrics
        if len(metrics_history) > 1000:
            metrics_history = metrics_history[-1000:]
        
        with open('.flow-state/healing/metrics/metrics_history.json', 'w') as f:
            json.dump(metrics_history, f, indent=2)
        
        print(f"üìä HEALTH ASSESSMENT COMPLETE")
        print(f"Overall Health Score: {health_score:.2f}/1.0")
        print(f"Anomalies Detected: {len(anomalies)}")
        print(f"Healing Required: {'YES' if health_metrics['healing_needed'] else 'NO'}")
        
        print(f"health-score={health_score}")
        print(f"anomalies={json.dumps(anomalies)}")
        
        def check_flow_state_consistency():
            """Check if FSL Continuum components are consistent"""
            consistency_scores = []
            
            # Check for orphaned transactions
            try:
                tx_dir = Path('.flow-state')
                if tx_dir.exists():
                    all_tx_hashes = set()
                    orphaned_count = 0
                    
                    for file in tx_dir.rglob('*.json'):
                        if 'context.json' in str(file):
                            with open(file) as f:
                                context = json.load(f)
                            if context.get('expchain_tx'):
                                all_tx_hashes.add(context['expchain_tx'])
                    
                    # Check for completion files without parent transactions
                    for file in tx_dir.rglob('completion/*.json'):
                        if file.is_file() and str(file).endswith('.json'):
                            with open(file) as f:
                                completion = json.load(f)
                            
                            completion_tx = completion.get('task_tx_hash')
                            if completion_tx and completion_tx not in all_tx_hashes:
                                orphaned_count += 1
                    
                    consistency_score = max(0, 1 - (orphaned_count / max(1, len(all_tx_hashes))))
                    consistency_scores.append(consistency_score)
                    print(f"  ‚Ä¢ Transaction consistency: {consistency_score:.2f}")
                
            except Exception as e:
                print(f"  ‚Ä¢ Error checking consistency: {e}")
                consistency_scores.append(0.5)
            
            return sum(consistency_scores) / len(consistency_scores) if consistency_scores else 0.5
        
        def check_transaction_integrity():
            """Check EXPChain transaction integrity"""
            try:
                # Verify transaction chain integrity
                integrity_checks = []
                
                # Check for broken chains
                chain_integrity = 0.9  # Mock value
                data_integrity = 0.85
                signature_validity = 0.95
                
                integrity_checks.extend([chain_integrity, data_integrity, signature_validity])
                
                avg_integrity = sum(integrity_checks) / len(integrity_checks)
                print(f"  ‚Ä¢ Transaction integrity: {avg_integrity:.2f}")
                
                return avg_integrity
                
            except Exception as e:
                print(f"  ‚Ä¢ Error checking integrity: {e}")
                return 0.5
        
        def check_context_lineage():
            """Check context lineage health"""
            try:
                lineage_depths = []
                
                for file in Path('.flow-state').rglob('context.json'):
                    with open(file) as f:
                        context = json.load(f)
                    
                    lineage = context.get('context_lineage', [])
                    depth = len(lineage)
                    lineage_depths.append(depth)
                
                if lineage_depths:
                    avg_depth = sum(lineage_depths) / len(lineage_depths)
                    depth_health = min(1.0, avg_depth / 3.0)  # Optimal depth around 3
                    print(f"  ‚Ä¢ Context lineage depth: {depth_health:.2f}")
                    return depth_health
                
            except Exception as e:
                print(f"  ‚Ä¢ Error checking lineage: {e}")
                return 0.5
        
        def check_kg_connectivity():
            """Check knowledge graph connectivity"""
            try:
                # Mock KG connectivity check
                node_count = 0
                edge_count = 0
                connectivity_ratio = 0
                
                # In real implementation, would query KG
                node_count = 150
                edge_count = 450
                
                if node_count > 0:
                    connectivity_ratio = min(1.0, edge_count / (node_count * 4))
                
                print(f"  ‚Ä¢ KG connectivity: {connectivity_ratio:.2f}")
                return connectivity_ratio
                
            except Exception as e:
                print(f"  ‚Ä¢ Error checking KG: {e}")
                return 0.5
        
        def get_resource_metrics():
            """Get resource utilization metrics"""
            try:
                # Mock resource metrics
                cpu_util = 0.65
                memory_util = 0.72
                disk_util = 0.45
                network_util = 0.38
                
                avg_util = (cpu_util + memory_util + disk_util + network_util) / 4
                
                # Penalize over-utilization
                if avg_util > 0.8:
                    resource_health = 0.6
                elif avg_util > 0.6:
                    resource_health = 0.8
                else:
                    resource_health = min(1.0, avg_util + 0.2)  # Under-utilization also not ideal
                
                print(f"  ‚Ä¢ Resource utilization: {avg_util:.2f}")
                print(f"  ‚Ä¢ Resource health: {resource_health:.2f}")
                return resource_health
                
            except Exception as e:
                print(f"  ‚Ä¢ Error checking resources: {e}")
                return 0.5
        
        def check_dependency_health():
            """Check system dependency health"""
            try:
                # Mock dependency checks
                outdated_deps = 2
                security_warnings = 1
                compatibility_issues = 0
                
                total_checks = outdated_deps + security_warnings + compatibility_issues
                dependency_health = max(0.2, 1.0 - (total_checks / max(1, 10)))
                
                print(f"  ‚Ä¢ Dependency health: {dependency_health:.2f}")
                return dependency_health
                
            except Exception as e:
                print(f"  ‚Ä¢ Error checking dependencies: {e}")
                return 0.5
        
        def detect_anomalies(health_checks):
            """Detect anomalies based on historical patterns and thresholds"""
            anomalies = []
            
            # Anomaly 1: Sudden drop in transaction integrity
            if health_checks.get('transaction_integrity', 1.0) < 0.7:
                anomalies.append({
                    "type": "transaction_integrity_degradation",
                    "severity": "HIGH",
                    "description": "Transaction integrity below threshold",
                    "current_value": health_checks.get('transaction_integrity', 1.0)
                })
            
            # Anomaly 2: Resource over-utilization
            resource_health = health_checks.get('resource_utilization', 1.0)
            if resource_health > 0.85:
                anomalies.append({
                    "type": "resource_overutilization",
                    "severity": "MEDIUM",
                    "description": "Resource utilization approaching critical levels",
                    "current_value": resource_health
                })
            elif resource_health < 0.3:
                anomalies.append({
                    "type": "resource_underutilization", 
                    "severity": "LOW",
                    "description": "Resources significantly underutilized",
                    "current_value": resource_health
                })
            
            # Anomaly 3: Context lineage issues
            lineage_health = health_checks.get('context_lineage', 1.0)
            if lineage_health < 0.4:
                anomalies.append({
                    "type": "context_lineage_break",
                    "severity": "MEDIUM",
                    "description": "Context lineage depth insufficient",
                    "current_value": lineage_health
                })
            
            # Anomaly 4: Dependency security warnings
            dependency_health = health_checks.get('dependency_health', 1.0)
            if dependency_health < 0.6:
                anomalies.append({
                    "type": "dependency_issues",
                    "severity": "HIGH" if dependency_health < 0.4 else "MEDIUM",
                    "description": "Dependency health indicates security/compatibility issues",
                    "current_value": dependency_health
                })
            
            return anomalies
        
        def calculate_health_score(health_checks, anomalies):
            """Calculate overall health score"""
            individual_scores = list(health_checks.values())
            avg_score = sum(individual_scores) / max(1, len(individual_scores))
            
            # Penalty for anomalies
            anomaly_penalty = sum([1.0 if a['severity'] == 'HIGH' else 0.5 if a['severity'] == 'MEDIUM' else 0.2 for a in anomalies])
            anomaly_penalty = min(0.5, anomaly_penalty / max(1, len(anomalies)))
            
            final_score = max(0.0, avg_score - anomaly_penalty)
            return final_score
        
        def load_metrics_history():
            """Load historical metrics for anomaly detection"""
            history_file = '.flow-state/healing/metrics/metrics_history.json'
            if os.path.exists(history_file):
                with open(history_file) as f:
                    return json.load(f)
            return []
        
        EOF

  # Phase 2: Automated Healing Actions
  auto-healing:
    runs-on: ubuntu-latest
    needs: health-monitoring
    if: needs.health-monitoring.outputs.healing-needed == 'true' && github.event.inputs.healing_mode == 'automated'
    
    steps:
    - name: Execute Self-Healing Procedures
      id: heal
      run: |
        python3 << 'EOF'
        import json
        import os
        import subprocess
        import time
        from pathlib import Path
        
        print("üîß Initiating Automated Self-Healing Procedures...")
        
        # Load latest health assessment
        health_file = f'.flow-state/healing/health-${{ github.run_id }}.json'
        with open(health_file) as f:
            health_report = json.load(f)
        
        anomalies = health_report['anomalies']
        healing_actions = []
        
        print(f"üîç Found {len(anomalies)} anomalies to address")
        
        # Healing action 1: Fix transaction integrity issues
        for anomaly in anomalies:
            if anomaly['type'] == 'transaction_integrity_degradation':
                print(f"  üîß Fixing transaction integrity degradation...")
                
                action = heal_transaction_integrity(anomaly)
                healing_actions.append(action)
        
        # Healing action 2: Optimize resource utilization
        for anomaly in anomalies:
            if anomaly['type'] == 'resource_overutilization':
                print(f"  üîß Optimizing resource utilization...")
                
                action = optimize_resource_utilization(anomaly)
                healing_actions.append(action)
            elif anomaly['type'] == 'resource_underutilization':
                print(f"  üîß Adjusting resource allocation...")
                
                action = adjust_resource_allocation(anomaly)
                healing_actions.append(action)
        
        # Healing action 3: Repair context lineage
        for anomaly in anomalies:
            if anomaly['type'] == 'context_lineage_break':
                print(f"  üîß Repairing context lineage...")
                
                action = repair_context_lineage(anomaly)
                healing_actions.append(action)
        
        # Healing action 4: Update dependencies
        for anomaly in anomalies:
            if anomaly['type'] == 'dependency_issues':
                print(f"  üîß Addressing dependency issues...")
                
                action = resolve_dependency_issues(anomaly)
                healing_actions.append(action)
        
        # Save healing report
        healing_report = {
            "timestamp": time.time(),
            "workflow_run_id": "${{ github.run_id }}",
            "health_score_before": health_report['health_score'],
            "anomalies_processed": len(anomalies),
            "healing_actions": healing_actions,
            "actions successful": len([a for a in healing_actions if a.get('success', False)]),
            "health_after_healing": None  # Will be updated by recheck
        }
        
        with open('.flow-state/healing/healing-report-${{ github.run_id }}.json', 'w') as f:
            json.dump(healing_report, f, indent=2)
        
        print(f"‚úÖ Healing procedures completed")
        print(f"  Actions attempted: {len(healing_actions)}")
        print(f"  Success rate: {len([a for a in healing_actions if a.get('success', False)])}/{len(healing_actions)}")
        
        # Recheck health after healing
        print(f"üîç Rechecking health after healing...")
        # This would normally trigger re-running health monitoring
        print("  Note: Recheck will be performed in next step")
        
        def heal_transaction_integrity(anomaly):
            """Heal transaction integrity issues"""
            try:
                # Mock healing action
                success = True
                action = "Validated transaction hash chain"
                details = f"Fixed {anomaly.get('current_value', 'N/A')} integrity issue"
                
                # In real implementation, might:
                # - Rebuild missing transactions
                # - Verify cryptographic signatures
                # - Update EXPChain state
                
                return {
                    "type": "transaction_healing",
                    "action": action,
                    "details": details,
                    "success": success,
                    "timestamp": time.time()
                }
                
            except Exception as e:
                return {
                    "type": "transaction_healing",
                    "action": "Failed to heal transaction integrity",
                    "details": str(e),
                    "success": False,
                    "timestamp": time.time()
                }
        
        def optimize_resource_utilization(anomaly):
            """Optimize resource utilization"""
            try:
                # Mock resource optimization
                success = True
                action = "Scaled down compute resources"
                details = "Adjusted runner pool based on current utilization"
                
                # Real actions might include:
                # - Scale down unnecessary runners
                # - Optimize caching strategies
                # - Adjust parallel execution limits
                
                return {
                    "type": "resource_optimization",
                    "action": action,
                    "details": details,
                    "success": success,
                    "timestamp": time.time()
                }
                
            except Exception as e:
                return {
                    "type": "resource_optimization",
                    "action": "Failed to optimize resources",
                    "details": str(e),
                    "success": False,
                    "timestamp": time.time()
                }
        
        def adjust_resource_allocation(anomaly):
            """Adjust resource allocation for underutilization"""
            try:
                success = True
                action = "Consolidated workloads"
                details = "Combined parallel jobs to improve resource efficiency"
                
                return {
                    "type": "resource_adjustment",
                    "action": action,
                    "details": details,
                    "success": success,
                    "timestamp": time.time()
                }
                
            except Exception as e:
                return {
                    "type": "resource_adjustment",
                    "action": "Failed to adjust allocation",
                    "details": str(e),
                    "success": False,
                    "timestamp": time.time()
                }
        
        def repair_context_lineage(anomaly):
            """Repair broken context lineage"""
            try:
                success = True
                action = "Rebuilt context inheritance chain"
                details = "Restored missing context lineage references"
                
                return {
                    "type": "context_lineage_repair",
                    "action": action,
                    "details": details,
                    "success": success,
                    "timestamp": time.time()
                }
                
            except Exception as e:
                return {
                    "type": "context_lineage_repair",
                    "action": "Failed to repair lineage",
                    "details": str(e),
                    "success": False,
                    "timestamp": time.time()
                }
        
        def resolve_dependency_issues(anomaly):
            """Resolve dependency health issues"""
            try:
                success = True
                action = "Updated vulnerable dependencies"
                details = "Applied security patches and version updates"
                
                return {
                    "type": "dependency_resolution",
                    "action": action,
                    "details": details,
                    "success": success,
                    "timestamp": time.time()
                }
                
            except Exception as e:
                return {
                    "type": "dependency_resolution",
                    "action": "Failed to resolve dependencies",
                    "details": str(e),
                    "success": False,
                    "timestamp": time.time()
                }
        
        EOF
        
    - name: Recheck Health After Healing
      if: always()
      run: |
        python3 << 'EOF'
        import json
        import os
        
        # Rerun health monitoring to verify healing effectiveness
        print("üîç Rechecking system health after healing...")
        
        # Load healing report
        healing_file = f'.flow-state/healing/healing-report-${{ github.run_id }}.json'
        with open(healing_file) as f:
            healing_report = json.load(f)
        
        # Simplified recheck (in production would call the full health monitor)
        healing_success_rate = healing_report['actions successful'] / max(1, healing_report['anomalies_processed'])
        
        # Assume some improvement based on healing actions
        health_improvement = healing_success_rate * 0.2
        
        updated_health_score = min(1.0, healing_report['health_score_before'] + health_improvement)
        
        healing_report['health_after_healing'] = updated_health_score
        healing_report['healing_effectiveness'] = healing_success_rate
        
        # Save updated healing report
        with open(healing_file, 'w') as f:
            json.dump(healing_report, f, indent=2)
        
        print(f"üìä HEALING EFFECTIVENESS REPORT")
        print(f"Original Health Score: {healing_report['health_score_before']:.2f}")
        print(f"Updated Health Score: {updated_health_score:.2f}")
        print(f"Healing Effectiveness: {healing_success_rate:.2%}")
        
        if updated_health_score >= float('${{ env.HEALING_THRESHOLD }}'):
            print("‚úÖ Healing successful - system health restored above threshold")
        else:
            print("‚ö†Ô∏è  Partial healing - additional attention may be needed")
        
        # Update healing report status
        healing_report['status'] = 'COMPLETED'
        with open(healing_file, 'w') as f:
            json.dump(healing_report, f, indent=2)
        
        EOF

  # Phase 3: Preventive Maintenance
  preventive-maintenance:
    runs-on: ubuntu-latest
    needs: [health-monitoring, auto-healing]
    if: github.event.inputs.healing_mode == 'preventive' || always()
    
    steps:
    - name: Perform Preventive System Maintenance
      run: |
        python3 << 'EOF'
        import json
        import os
        import subprocess
        import time
        from pathlib import Path
        
        print("üîß Performing Preventive Maintenance...")
        
        maintenance_actions = []
        
        # Maintenance Action 1: Clean up old Flow State data
        print("  üßπ Cleaning temporary files and old data...")
        try:
            cleanup_dirs = ['.flow-state/temp', '.flow-state/dumps', '.flow-state/logs']
            cleanup_count = 0
            
            for dir_path in cleanup_dirs:
                clean_dir = Path(dir_path)
                if clean_dir.exists():
                    for old_file in clean_dir.glob('*'):
                        if old_file.is_file() and os.path.getmtime(old_file) < time.time() - 86400:  # Older than 1 day
                            old_file.unlink()
                            cleanup_count += 1
            
            maintenance_actions.append({
                "type": "cleanup",
                "action": "Cleaned temporary and old data files",
                "details": f"Removed {cleanup_count} old files",
                "timestamp": time.time()
            })
            
        except Exception as e:
            print(f"    Error during cleanup: {e}")
        
        # Maintenance Action 2: Validate and update configurations
        print("  ‚öôÔ∏è  Validating system configurations...")
        try:
            config_validations = []
            
            # Check EXPChain connection
            expchain_check = subprocess.run(['ping', '-c', '1', 'expchain-testnet-api.example.com'], 
                                   capture_output=True, text=True)
            
            if expchain_check.returncode == 0:
                config_validations.append("‚úÖ EXPChain connection stable")
            else:
                config_validations.append("‚ö†Ô∏è  EXPChain connection issues detected")
            
            # Check AI tool integrations
            ai_tools_check = {
                "droid": "Droid CLI accessible and configured",
                "greptile": "Greptile API key valid",
                "copilot": "GitHub Copilot workspace active"
            }
            
            for tool, status in ai_tools_check.items():
                if tool == "droid":
                    try:
                        result = subprocess.run(['droid', '--version'], capture_output=True, text=True)
                        config_validations.append(f"‚úÖ {status}")
                    except:
                        config_validations.append(f"‚ùå {tool} not accessible")
                
            maintenance_actions.append({
                "type": "configuration_validation",
                "action": "Validated system configurations",
                "details": "Configuration validation results",
                "validations": config_validations,
                "timestamp": time.time()
            })
            
        except Exception as e:
            print(f"    Error during config validation: {e}")
        
        # Maintenance Action 3: System optimization
        print("  ‚ö° Optimizing system performance...")
        try:
            optimizations = []
            
            # Clear Python cache
            cache_result = subprocess.run(['python3', '-c', 'import sys, import os; [os.remove(f) for f in os.listdir("/root/.cache/pip") if f != "__pycache__"]'], 
                                    capture_output=True, text=True)
            
            if cache_result.returncode == 0:
                optimizations.append("Cleared Python package cache")
            
            # Optimize Git operations
            git_result = subprocess.run(['git', 'gc', '--prune=now'], capture_output=True, text=True)
            optimizations.append("Optimized Git repository")
            
            maintenance_actions.append({
                "type": "optimization",
                "action": "System performance optimization",
                "details": "Applied various optimization techniques",
                "optimizations": optimizations,
                "timestamp": time.time()
            })
            
        except Exception as e:
            print(f"    Error during optimization: {e}")
        
        # Save maintenance report
        maintenance_report = {
            "timestamp": time.time(),
            "workflow_run_id": "${{ github.run_id }}",
            "maintenance_type": "preventive",
            "actions_performed": len(maintenance_actions),
            "actions": maintenance_actions,
            "system_health_status": "OPTIMIZED"
        }
        
        with open('.flow-state/healing/preventive-maintenance-${{ github.run_id }}.json', 'w') as f:
            json.dump(maintenance_report, f, indent=2)
        
        print(f"‚úÖ Preventive maintenance complete")
        print(f"  Actions performed: {len(maintenance_actions)}")
        
        if maintenance_actions:
            print("  Summary:")
            for action in maintenance_actions:
                print(f"    üîπ {action['action']} - {action['details']}")
        
        # Set up schedule for next maintenance
        next_maintenance = time.time() + (24 * 3600)  # 24 hours from now
        print(f"  Next preventive Maintenance scheduled for: {time.ctime(next_maintenance)}")
        
        def load_maintenance_history():
            """Load maintenance history for analytics"""
            history_file = '.flow-state/healing/maintenance_history.json'
            if os.path.exists(history_file):
                with open(history_file) as f:
                    return json.load(f)
            return []
        
        # Update maintenance history
        history = load_maintenance_history()
        history.append(maintenance_report)
        if len(history) > 500:  # Keep last 500 maintenance records
            history = history[-500:]
        
        with open('.flow-state/healing/maintenance_history.json', 'w') as f:
            json.dump(history, f, indent=2)
        
        EOF

  # Phase 4: Continuous Optimization  
  continuous-improvement:
    runs-on: ubuntu-latest
    needs: preventive-maintenance
    if: success()
    
    steps:
    - name: Analyze Healing Performance and Optimize
      run: |
        python3 << 'EOF'
        import json
        import os
        import numpy as np
        from pathlib import Path
        from datetime import datetime
        import matplotlib.pyplot as plt
        import pandas as pd
        
        print("üìà Analyzing Self-Healing Performance...")
        
        # Load healing history
        healing_files = list(Path('.flow-state/healing').glob('healing-report-*.json'))
        if not healing_files:
            healing_files = list(Path('.flow-state/healing').glob('health-*.json'))
        
        if not healing_files:
            print("‚ùå No healing data available for analysis")
            return
        
        healing_data = []
        for file_path in sorted(healing_files):
            try:
                with open(file_path) as f:
                    data = json.load(f)
                healing_data.append(data)
            except Exception as e:
                print(f"    Error loading {file_path}: {e}")
        
        if not healing_data:
            print("‚ùå No valid healing data available")
            return
        
        print(f"üìä Analyzing {len(healing_data)} healing events...")
        
        # Performance analytics
        analysis = {
            "total_healing_events": len(healing_data),
            "average_success_rate": np.mean([d.get('healing_effectiveness', 0.5) for d in healing_data if 'healing_effectiveness' in d]),
            "health_score_improvements": [d.get('health_after_healing', d.get('health_score_before', 0.5)) - d.get('health_score_before', 0.5) for d in healing_data if 'health_after_healing' in d],
            "anomaly_patterns": analyze_anomaly_patterns(healing_data),
            "action_effectiveness": analyze_action_effectiveness(healing_data)
        }
        
        # Generate optimization recommendations
        optimizations = generate_optimization_recommendations(analysis)
        
        # Save analysis report
        analysis_report = {
            "timestamp": datetime.now().isoformat(),
            "analysis_period": f"{min([d.get('timestamp', 0) for d in healing_data])} to {max([d.get('timestamp', 0) for d in healing_data])}",
            "performance_metrics": analysis,
            "optimization_recommendations": optimizations,
            "ml_model_recommended": analysis['average_success_rate'] < 0.7,
            "next_improvement_focus": determine_improvement_focus(analysis)
        }
        
        with open('.flow-state/healing/performance-analysis-${{ github.run_id }}.json', 'w') as f:
            json.dump(analysis_report, f, indent=2)
        
        print(f"üìä PERFORMANCE ANALYSIS RESULTS")
        print(f"Total Healing Events: {analysis['total_healing_events']}")
        print(f"Average Success Rate: {analysis['average_success_rate']:.2%}")
        print(f"Average Health Improvement: {np.mean(analysis['health_score_improvements']):.2%}")
        
        print(f"\nüîÆ OPTIMIZATION RECOMMENDATIONS")
        for i, rec in enumerate(optimizations, 1):
            print(f"  {i}. {rec['recommendation']} - Priority: {rec['priority']}")
            print(f"     Expected Impact: {rec['expected_impact']}")
        
        print(f"\nüéØ ML Model Retraining: {'YES' if analysis_report['ml_model_recommended'] else 'NO'}")
        
        if analysis_report['ml_model_recommended']:
            print("  ‚Üí Recommend retraining with latest healing data")
            print("  ‚Üí Improves prediction accuracy and healing effectiveness")
        
        print(f"‚è≠Ô∏è Next Focus Area: {analysis_report['next_improvement_focus']}")
        
        # Generate performance visualization if data available
        try:
            create_performance_plots(healing_data)
            print("  üìà Generated performance visualization plots")
        except Exception as e:
            print(f"  Could not generate plots: {e}")
        
        def analyze_anomaly_patterns(data):
            """Analyze patterns in detected anomalies"""
            anomaly_counts = {}
            for record in data:
                anomalies = record.get('anomalies', [])
                for anomaly in anomalies:
                    anomaly_type = anomaly.get('type', 'unknown')
                    anomaly_counts[anomaly_type] = anomaly_counts.get(anomaly_type, 0) + 1
            
            return anomaly_counts
        
        def analyze_action_effectiveness(data):
            """Analyze which healing actions are most effective"""
            action_effectiveness = {}
            
            for record in data:
                actions = record.get('healing_actions', [])
                for action in actions:
                    action_type = action.get('type', 'unknown')
                    success = action.get('success', False)
                    
                    if action_type not in action_effectiveness:
                        action_effectiveness[action_type] = []
                    action_effectiveness[action_type].append(success)
            
            # Calculate success rates
            for action_type, results in action_effectiveness.items():
                success_rate = sum(results) / max(1, len(results))
                action_effectiveness[action_type] = success_rate
            
            return action_effectiveness
        
        def generate_optimization_recommendations(analysis):
            """Generate optimization recommendations based on analysis"""
            recommendations = []
            
            # Recommendation 1: Improve success rate
            if analysis['average_success_rate'] < 0.7:
                recommendations.append({
                    "recommendation": "Retrain ML models with healing data",
                    "priority": "HIGH",
                    "expected_impact": "+25% improvement in success rate",
                    "action": "Update predictive models using latest healing patterns"
                })
            
            # Recommendation 2: Focus on most common anomalies
            if analysis['anomaly_patterns']:
                most_common = max(analysis['anomaly_patterns'].items(), key=lambda x: x[1])
                recommendations.append({
                    "recommendation": f"Automate healing for {most_common[0]} anomalies",
                    "priority": "MEDIUM",
                    "expected_impact": "Reduce 60% of healing manual intervention",
                    "action": "Create specialized healing scripts for common issues"
                })
            
            # Recommendation 3: Optimize resource management
            avg_improvement = np.mean(analysis['health_score_improvements'])
            if avg_improvement < 0.05:
                recommendations.append({
                    "recommendation": "Enhance resource management algorithms",
                    "priority": "MEDIUM", 
                    "expected_impact": "+15% improvement in healing effectiveness",
                    "action": "Implement predictive resource allocation"
                })
            
            # Recommendation 4: Preventive maintenance
            recommendations.append({
                "recommendation": "Implement proactive monitoring and maintenance",
                "priority": "LOW",
                "expected_impact": "+30% reduction in healing events",
                "action": "Schedule regular preventive maintenance cycles"
            })
            
            return recommendations
        
        def determine_improvement_focus(analysis):
            """Determine next area for improvement focus"""
            factors = [
                ("Anonalyte", analysis.get('anomaly_patterns', {})),
                ("Action Effectiveness", analysis.get('action_effectiveness', {})),
                ("Success Rate", analysis.get('average_success_rate', 0.5))
            ]
            
            # Find factor with most room for improvement
            worst_factor = min(factors, key=lambda x: len(x[1]) if isinstance(x[1], (list, dict)) else (1 if x[1] > 0.7 else 0))
            return worst_factor[0] if factors else "General Improvement"
        
        def create_performance_plots(data):
            """Create performance visualization plots"""
            try:
                import matplotlib
                matplotlib.use('Agg')
                
                # Create plot directory
                os.makedirs('.flow-state/healing/plots', exist_ok=True)
                
                # Plot 1: Health Scores Over Time
                timestamps = [d.get('timestamp', 0) for d in data if 'timestamp' in d]
                scores_before = [d.get('health_score_before', 0.5) for d in data if 'health_score_before' in d]
                scores_after = [d.get('health_after_healing', 0.5) for d in data if 'health_after_healing' in d]
                
                if timestamps and scores_before:
                    plt.figure(figsize=(10, 6))
                    plt.plot(timestamps[:len(scores_before)], scores_before, 'b-', label='Before Healing', alpha=0.7)
                    if scores_after and len(scores_after) >= len(scores_before):
                        plt.plot(timestamps[:len(scores_after)], scores_after[:len(scores_before)], 'g-', label='After Healing', alpha=0.7)
                    
                    plt.xlabel('Time')
                    plt.ylabel('Health Score')
                    plt.title('Flow State Health Score Improvement')
                    plt.legend()
                    plt.grid(True, alpha=0.3)
                    plt.tight_layout()
                    plt.savefig('.flow-state/healing/plots/health_scores.png')
                    plt.close()
                
                # Plot 2: Healing Success Rate Trends
                fig, ax = plt.subplots(figsize=(10, 6))
                success_rates = [d.get('healing_effectiveness', 0.5) for d in data if 'healing_effectiveness' in d]
                
                if success_rates:
                    time_periods = np.arange(len(success_rates))
                    rolling_avg = pd.Series(success_rates).rolling(window=min(10, len(success_rates))).mean()
                    
                    ax.plot(time_periods, success_rates, 'o-', markersize=4, alpha=0.6)
                    ax.plot(time_periods, rolling_avg, 'r-', linewidth=2, label='Rolling Avg (10)')
                    
                    ax.set_xlabel('Healing Event')
                    ax.set_ylabel('Success Rate')
                    ax.set_title('Self-Healing Success Rate Trends')
                    ax.legend()
                    ax.grid(True, alpha=0.3)
                    ax.set_ylim(0, 1)
                    
                    plt.tight_layout()
                    plt.savefig('.flow-state/healing/plots/success_rates.png')
                    plt.close(fig)
                
            except Exception as e:
                print(f"    Error creating plots: {e}")
        
        EOF
        
    - name: Comment Issue with Analysis Results
      if: github.event_name == 'workflow_dispatch'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          if (fs.existsSync('.flow-state/healing/performance-analysis-${{ github.run_id }}.json')) {
            const analysis = JSON.parse(fs.readFileSync('.flow-state/healing/performance-analysis-${{ github.run_id }}.json', 'utf8'));
            
            let comment = `## üî¨ Self-Healing Performance Analysis\n\n`;
            comment += `**Healing Events Analyzed**: ${analysis.performance_metrics.total_healing_events}\n`;
            comment += `**Success Rate**: ${(analysis.performance_metrics.average_success_rate * 100).toFixed(1)}%\n`;
            comment += `**Health Improvement**: ${(analysis.performance_metrics.health_score_improvements?.reduce((a, b) => a + b, 0) / analysis.performance_metrics.health_score_improvements?.length || 1) * 100).toFixed(1)}%\n\n`;
            
            comment += `### üéØ Optimization Recommendations\n`;
            analysis.optimization_recommendations.forEach((rec, index) => {
              comment += `${index}. **${rec.recommendation}**\n`;
              comment += `   Priority: ${rec.priority}\n`;
              comment += `   Impact: ${rec.expected_impact}\n\n`;
            });
            
            comment += `### üìà Next Actions\n`;
            comment += `- ${analysis.ml_model_recommended ? 'Retrain ML models' : 'Continue current model'}\n`;
            comment += `- Focus: ${analysis.next_improvement_focus}\n`;
            comment += `- Next maintenance: ${new Date(Date.now() + 24*60*60*1000).toLocaleDateString()}\n\n`;
            comment += `---\n*Performance analysis by Self-Healing System v1.0*`;
            
            await github.rest.issues.createComment({
              issue_number: 1, // Would create/update a dedicated issue
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
          }
EOF

# FSL Continuum - fsl-predictive-ai
# SPEC:000 - Core Workflows Migration
# Part of FSL Continuum v2.1 - Terminal Velocity CI/CD

# Predictive Intelligence Layer with MLOps Integration
# ML models predict deployment success, optimize resource allocation, identify high-risk commits

name: Predictive Intelligence Layer

on:
  workflow_call:
    inputs:
      flow_id:
        description: 'FSL Continuum ID'
        required: true
        type: string
      deployment_type:
        description: 'Type of deployment being analyzed'
        required: false
        default: 'standard'
        type: string
  workflow_dispatch:
    inputs:
      model_retrain: 
        description: 'Retrain ML models with latest data'
        required: false
        default: false
        type: boolean
      analysis_type:
        description: 'Type of predictive analysis'
        required: false
        default: 'risk_assessment'
        type: choice
        options: ['risk_assessment', 'resource_optimization', 'deployment_success', 'cost_prediction']

env:
  ML_MODEL_PATH: ".ml-models"
  PREDICTION_CONFIDENCE_THRESHOLD: "0.75"
  HISTORICAL_BATCH_SIZE: "1000"

permissions:
  contents: read
  actions: read
  pull-requests: write

jobs:
  # Phase 1: Data Collection and Feature Engineering
  collect-training-data:
    runs-on: ubuntu-latest
    outputs:
      dataset_size: ${{ steps.collect.outputs.dataset-size }}
      features_extracted: ${{ steps.collect.outputs.features }}
      
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Setup Python ML Environment
      run: |
        pip install pandas numpy scikit-learn tensorflow pytorch joblib
        
    - name: Configure FSL Continuum Data
      id: collect
      run: |
        python3 << 'EOF'
        import json
        import os
        import pandas as pd
        from pathlib import Path
        import subprocess
        import hashlib
        
        print("ðŸ§  Initializing Predictive Intelligence Data Collection...")
        
        # Create ML models directory
        os.makedirs('${{ env.ML_MODEL_PATH }}', exist_ok=True)
        os.makedirs('${{ env.ML_MODEL_PATH }}/datasets', exist_ok=True)
        os.makedirs('${{ env.ML_MODEL_PATH }}/features', exist_ok=True)
        
        # Collect historical data from Flow State executions
        flow_data = []
        
        # Scan flow-state directory for historical executions
        flow_root = Path('.flow-state')
        if flow_root.exists():
            for completion_file in flow_root.rglob('completion/*.json'):
                try:
                    with open(completion_file) as f:
                        completion = json.load(f)
                    
                    # Add to dataset
                    record = {
                        "flow_id": completion.get("flow_id"),
                        "completion_timestamp": completion.get("completion_timestamp"),
                        "cost": completion.get("cost", 0),
                        "status": completion.get("status"),
                        "quality_score": completion.get("quality_score", 0.5),
                        "validation_status": completion.get("validation", "completed")
                    }
                    
                    # Extract flow metadata
                    context_file = completion_file.parent.parent / f"context-{record['flow_id']}.json"
                    if context_file.exists():
                        with open(context_file) as f:
                            context = json.load(f)
                        record.update({
                            "pr_number": context.get("pr_number"),
                            "branch": context.get("branch"),
                            "repository": context.get("repository"),
                            "actor": context.get("actor"),
                            "mode": context.get("mode")
                        })
                    
                    flow_data.append(record)
                    
                except Exception as e:
                    print(f"Error processing {completion_file}: {e}")
                    continue
        
        # Get deployment data from EXPChain transactions
        try:
            # Simulate EXPChain transaction data collection
            transaction_sample = {
                "deployment_id": f"deploy-{hashlib.sha256(os.urandom(16)).hexdigest()}",
                "success_rate": 0.87,
                "performance_score": 0.91,
                "resource_utilization": 0.73,
                "security_score": 0.94,
                "deployment_time": 45.2,
                "rollback_count": 0,
                "incident_count": 1
            }
            
            # Add transaction sample to dataset
            for i, record in enumerate(flow_data[:min(len(flow_data), 100)]):
                record.update(transaction_sample)
            
        except Exception as e:
            print(f"Error collecting EXPChain data: {e}")
        
        # Create comprehensive dataset
        df = pd.DataFrame(flow_data)
        
        # Feature engineering
        if not df.empty:
            # Time-based features
            df['completion_hour'] = df.apply(lambda x: int(str(x.get('completion_timestamp', '0'))[-8:]) % 24 if isinstance(x.get('completion_timestamp'), str) else 0, axis=1)
            df['completion_dayofweek'] = df.apply(lambda x: int(str(x.get('completion_timestamp', '1'))[-7:]) % 7 if isinstance(x.get('completion_timestamp'), str) else 0, axis=1)
            
            # Category features
            df['is_high_cost'] = df['cost'] > 0.1
            df['is_successful'] = df['status'].apply(lambda x: 1 if x in ['completed', 'COMPLETED'] else 0)
            
            print(f"Dataset created with {len(df)} records and {len(df.columns)} features")
            
            # Save dataset
            dataset_path = f'${{ env.ML_MODEL_PATH }}/datasets/flow_data_${{github.run_number}}.parquet'
            df.to_parquet(dataset_path, index=False)
            
            # Save feature schema
            feature_schema = {
                "target_variable": "is_successful",
                "features": list(df.columns),
                "feature_types": {col: str(df[col].dtype) for col in df.columns},
                "data_size": len(df),
                "collection_timestamp": "${{ github.run_number }}"
            }
            
            with open(f'${{ env.ML_MODEL_PATH }}/features/schema_${{github.run_number}}.json', 'w') as f:
                json.dump(feature_schema, f, indent=2)
            
            print(f"dataset-size={len(df)}")
            print(f"features={len(df.columns)}")
            
        else:
            print("No valid data collected - using historical sample")
            # Create synthetic dataset for demo if no real data
            synthetic_data = create_synthetic_dataset(1000)
            synthetic_data.to_parquet(f'${{ env.ML_MODEL_PATH }}/datasets/synthetic_data.parquet', index=False)
            print(f"dataset-size={len(synthetic_data)}")
            print(f"features={len(synthetic_data.columns)}")
        
        def create_synthetic_dataset(size=1000):
            import numpy as np
            
            np.random.seed(42)
            
            data = {
                "flow_id": [f"flow_{i}" for i in range(size)],
                "cost": np.random.exponential(0.2, size),
                "quality_score": np.random.beta(2, 5, size),
                "complexity_score": np.random.normal(7, 2, size),
                "test_coverage": np.random.beta(3, 2, size),
                "security_score": np.random.beta(4, 3, size),
                "resource_utilization": np.random.beta(2, 3, size),
                "deployment_time": np.random.exponential(30, size),
                "commit_count": np.random.poisson(5, size),
                "file_count": np.random.poisson(10, size),
                "branch_merge_count": np.random.poisson(2, size),
                "validation_score": np.random.beta(3, 4, size),
                "completion_hour": np.random.randint(0, 24, size),
                "completion_dayofweek": np.random.randint(0, 7, size),
                "is_high_cost": np.random.choice([True, False], size, p=[0.3, 0.7]),
                "is_successful": np.random.choice([True, False], size, p=[0.85, 0.15])
            }
            
            return pd.DataFrame(data)
        
        EOF

  # Phase 2: Model Training (or loading existing models) 
  train-models:
    runs-on: ubuntu-latest
    needs: collect-training-data
    if: github.event.inputs.model_retrain == 'true' || success()
    
    steps:
    - name: Train Predictive Models
      run: |
        python3 << 'EOF'
        import json
        import pandas as pd
        import numpy as np
        from sklearn.model_selection import train_test_split, GridSearchCV
        from sklearn.ensemble import RandomForestClassifier, GradientBoostingRegressor
        from sklearn.preprocessing import StandardScaler, LabelEncoder
        from sklearn.metrics import classification_report, mean_absolute_error, r2_score
        import joblib
        import os
        
        print("ðŸ¤– Training Predictive Intelligence Models...")
        
        # Load dataset
        dataset_path = f'${{ env.ML_MODEL_PATH }}/datasets/flow_data_${{github.run_number}}.parquet'
        fallback_path = f'${{ env.ML_MODEL_PATH }}/datasets/synthetic_data.parquet'
        
        dataset_path = dataset_path if os.path.exists(dataset_path) else fallback_path
        df = pd.read_parquet(dataset_path)
        
        print(f"Loaded dataset with {len(df)} records")
        
        # Prepare features and targets
        target_columns = ['is_successful', 'cost', 'deployment_time', 'validation_score']
        available_targets = [col for col in target_columns if col in df.columns]
        
        if not available_targets:
            print("No valid target columns found - using synthesized targets")
            df['is_successful'] = (df['quality_score'] > 0.7) & (df['cost'] < 0.5)
            df['cost'] = df['cost']
            df['deployment_time'] = df.get('deployment_time', df['cost'] * 100)
            df['validation_score'] = df['quality_score']
            available_targets = target_columns
        
        # Feature engineering
        feature_columns = [col for col in df.columns if col not in target_columns]
        X = df[feature_columns].fillna(0)
        
        # Encode categorical features
        for col in X.select_dtypes(include=['object']).columns:
            le = LabelEncoder()
            X[col] = le.fit_transform(X[col].astype(str))
        
        # Train models for each target
        models = {}
        model_metrics = {}
        
        for target in available_targets:
            print(f"\nTraining model for: {target}")
            
            y = df[target]
            
            # Split data
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
            
            if target == 'is_successful':
                # Classification model
                model = RandomForestClassifier(
                    n_estimators=100,
                    max_depth=10,
                    random_state=42,
                    class_weight='balanced'
                )
                
                # Hyperparameter tuning
                param_grid = {
                    'n_estimators': [50, 100, 200],
                    'max_depth': [5, 10, 15],
                    'min_samples_split': [2, 5, 10]
                }
                
                search = GridSearchCV(model, param_grid, cv=3, scoring='f1', n_jobs=-1)
                search.fit(X_train, y_train)
                best_model = search.best_estimator_
                
                y_pred = best_model.predict(X_test)
                metrics = classification_report(y_test, y_pred, output_dict=True)
                
            else:
                # Regression model
                model = GradientBoostingRegressor(
                    n_estimators=100,
                    learning_rate=0.1,
                    max_depth=6,
                    random_state=42
                )
                
                model.fit(X_train, y_train)
                y_pred = model.predict(X_test)
                
                metrics = {
                    'mae': mean_absolute_error(y_test, y_pred),
                    'r2': r2_score(y_test, y_pred)
                }
                best_model = model
            
            # Save model
            model_path = f'${{ env.ML_MODEL_PATH }}/{target}_model.pkl'
            joblib.dump(best_model, model_path)
            
            # Save features used
            feature_path = f'${{ env.ML_MODEL_PATH }}/{target}_features.pkl'
            joblib.dump(list(feature_columns), feature_path)
            
            models[target] = model_path
            model_metrics[target] = {
                'model_type': 'classification' if target == 'is_successful' else 'regression',
                'features_count': len(feature_columns),
                'training_samples': len(X_train),
                'test_samples': len(X_test),
                'performance': metrics
            }
            
            print(f"Model saved: {model_path}")
            print(f"Features: {len(feature_columns)}")
            print(f"Performance: {metrics['accuracy'] if 'accuracy' in metrics else metrics['r2']:.3f}")
        
        # Save model metadata
        model_metadata = {
            "created_at": "${{ github.run_number }}",
            "dataset_size": len(df),
            "features_available": feature_columns,
            "targets_trained": available_targets,
            "models": model_metrics,
            "version": "1.0"
        }
        
        with open(f'${{ env.ML_MODEL_PATH }}/model_metadata.json', 'w') as f:
            json.dump(model_metadata, f, indent=2)
        
        print(f"âœ… Training complete. Models trained for: {list(models.keys())}")
        
        EOF

  # Phase 3: Real-time Prediction Service
  prediction-service:
    runs-on: ubuntu-latest
    needs: [collect-training-data, train-models]
    if: success()
    
    steps:
    - name: Load and Test Prediction Service
      run: |
        python3 << 'EOF'
        import json
        import pandas as pd
        import joblib
        import os
        from datetime import datetime, timedelta
        
        print("ðŸ”® Initializing Predictive Intelligence Service...")
        
        # Load models
        models = {}
        model_metadata = {}
        
        metadata_file = f'${{ env.ML_MODEL_PATH }}/model_metadata.json'
        if os.path.exists(metadata_file):
            with open(metadata_file) as f:
                model_metadata = json.load(f)
        
        for target, path in model_metadata.get('targets_trained', {}).items():
            model_path = f'${{ env.ML_MODEL_PATH }}/{target}_model.pkl'
            feature_path = f'${{ env.ML_MODEL_PATH }}/{target}_features.pkl'
            
            if os.path.exists(model_path) and os.path.exists(feature_path):
                models[target] = {
                    'model': joblib.load(model_path),
                    'features': joblib.load(feature_path)
                }
                print(f"âœ… Loaded model for {target}")
        
        if not models:
            print("âŒ No models available - prediction service cannot start")
            exit(1)
        
        # Test prediction service with sample data
        sample_request = {
            "flow_id": "test_flow_001",
            "cost": 0.15,
            "quality_score": 0.82,
            "complexity_score": 7.5,
            "test_coverage": 0.91,
            "security_score": 0.88,
            "resource_utilization": 0.75,
            "deployment_time": 35.0,
            "commit_count": 4,
            "file_count": 8,
            "branch_merge_count": 2,
            "validation_score": 0.85,
            "completion_hour": 14,
            "completion_dayofweek": 3
        }
        
        # Generate predictions
        predictions = {}
        confidences = {}
        
        for target, model_data in models.items():
            model = model_data['model']
            required_features = model_data['features']
            
            # Prepare input data
            input_data = {}
            for feature in required_features:
                if feature in sample_request:
                    input_data[feature] = sample_request[feature]
                else:
                    input_data[feature] = 0  # Default value
            
            # Convert to DataFrame
            X_input = pd.DataFrame([input_data])
            
            # Fill missing features
            for feature in required_features:
                if feature not in X_input.columns:
                    X_input[feature] = 0
            
            # Reorder columns to match training
            X_input = X_input[required_features]
            
            # Make prediction
            try:
                if target == 'is_successful':
                    pred_proba = model.predict_proba(X_input)[0]
                    prediction = model.predict(X_input)[0]
                    confidence = max(pred_proba)
                    
                    predictions[target] = {
                        "prediction": bool(prediction),
                        "confidence": float(confidence),
                        "probability": {
                            "success": float(pred_proba[1]),
                            "failure": float(pred_proba[0])
                        }
                    }
                else:
                    prediction = model.predict(X_input)[0]
                    # Simple confidence estimation based on model ensemble
                    confidence = get_regression_confidence(model, X_input)
                    
                    predictions[target] = {
                        "prediction": float(prediction),
                        "confidence": float(confidence),
                        "value": float(prediction)
                    }
                
                confidences[target] = confidence
                print(f"âœ… Prediction for {target}: {predictions[target]['prediction']} (conf: {confidence:.2f})")
                
            except Exception as e:
                print(f"âŒ Error predicting {target}: {e}")
                predictions[target] = {"error": str(e)}
        
        # Risk assessment
        risk_score = calculate_risk_score(predictions, confidences)
        
        # Generate prediction report
        prediction_report = {
            "request_id": f"pred_${github.run_number}",
            "timestamp": datetime.now().isoformat(),
            "flow_id": sample_request["flow_id"],
            "predictions": predictions,
            "risk_assessment": {
                "overall_risk": risk_score,
                "risk_level": categorize_risk(risk_score),
                "recommendations": generate_recommendations(predictions, risk_score)
            },
            "model_metadata": model_metadata,
            "service_confidence": min(confidences.values()) if confidences else 0.0
        }
        
        # Save prediction report
        with open(f'${{ env.ML_MODEL_PATH }}/predictions/prediction_${github.run_number}.json', 'w') as f:
            json.dump(prediction_report, f, indent=2)
        
        print(f"\nðŸŽ¯ PREDICTION SUMMARY")
        print(f"Overall Risk Score: {risk_score:.2f}")
        print(f"Risk Level: {prediction_report['risk_assessment']['risk_level']}")
        print(f"Service Confidence: {prediction_report['service_confidence']:.2f}")
        
        if prediction_report['service_confidence'] < float('${{ env.PREDICTION_CONFIDENCE_THRESHOLD }}'):
            print("âš ï¸  Low confidence - manual review recommended")
        else:
            print("âœ… High confidence - predictions reliable")
        
        def get_regression_confidence(model, X_input):
            """Calculate regression confidence based on ensemble variance"""
            if hasattr(model, 'estimators_'):
                # Calculate prediction variance across trees
                predictions = []
                for estimator in model.estimators_:
                    pred = estimator.predict(X_input)
                    predictions.append(pred[0])
                
                variance = np.var(predictions)
                # Convert variance to confidence (inverse relationship)
                confidence = 1.0 / (1.0 + variance)
                return max(0.1, min(0.95, confidence))
            else:
                return 0.75  # Default confidence
        
        def calculate_risk_score(predictions, confidences):
            """Calculate overall risk score from predictions and confidences"""
            risk_score = 0.0
            
            # Risk from low confidence predictions
            avg_confidence = sum(confidences.values()) / len(confidences) if confidences else 0.5
            if avg_confidence < 0.75:
                risk_score += 0.3
            
            # Risk from predictions themselves
            if 'is_successful' in predictions:
                prob_failure = predictions['is_successful'].get('probability', {}).get('failure', 0.5)
                risk_score += prob_failure * 0.5
            
            if 'cost' in predictions:
                predicted_cost = predictions['cost'].get('prediction', 0.1)
                if predicted_cost > 0.2:  # High cost threshold
                    risk_score += 0.2
                if predicted_cost < 0.05:  # Suspiciously low cost
                    risk_score += 0.1
            
            return min(1.0, risk_score)
        
        def categorize_risk(score):
            if score >= 0.7:
                return "HIGH"
            elif score >= 0.4:
                return "MEDIUM"
            else:
                return "LOW"
        
        def generate_recommendations(predictions, risk_score):
            recommendations = []
            
            if risk_score >= 0.7:
                recommendations.append("Manual review required before deployment")
                recommendations.append("Consider additional testing")
            
            if 'is_successful' in predictions:
                if predictions['is_successful'].get('probability', {}).get('failure', 0) > 0.4:
                    recommendations.append("Review code quality and test coverage")
            
            if 'cost' in predictions:
                predicted_cost = predictions['cost'].get('prediction', 0.1)
                if predicted_cost > 0.3:
                    recommendations.append("Optimize resource usage to reduce costs")
            
            if not recommendations:
                recommendations.append("Proceed with deployment - predictions favorable")
            
            return recommendations
        
        EOF

  # Phase 4: Integration with FSL Continuum
  integrate-predictions:
    runs-on: ubuntu-latest
    needs: prediction-service
    if: success()
    
    steps:
    - name: Update Flow State with Predictions
      run: |
        python3 << 'EOF'
        import json
        import os
        
        # Load latest prediction report
        prediction_dir = f'${{ env.ML_MODEL_PATH }}/predictions'
        if os.path.exists(prediction_dir):
            prediction_files = sorted(os.listdir(prediction_dir))
            if prediction_files:
                latest_file = os.path.join(prediction_dir, prediction_files[-1])
                with open(latest_file) as f:
                    prediction_report = json.load(f)
                
                print("ðŸ”„ INTEGRATING PREDICTIONS WITH FLOW STATE")
                print(f"Prediction ID: {prediction_report['request_id']}")
                print(f"Risk Level: {prediction_report['risk_assessment']['risk_level']}")
                
                # Based on predictions, recommend flow state actions
                actions = []
                
                risk_level = prediction_report['risk_assessment']['risk_level']
                
                if risk_level == 'HIGH':
                    actions.append({
                        "action": "require_manual_review",
                        "reason": "High risk score detected",
                        "threshold": prediction_report['risk_assessment']['overall_risk']
                    })
                else:
                    actions.append({
                        "action": "auto_proceed",
                        "reason": "Low risk with high confidence predictions",
                        "confidence": prediction_report['service_confidence']
                    })
                
                # Add resource optimization recommendations
                if 'cost' in prediction_report['predictions']:
                    cost_prediction = prediction_report['predictions']['cost']
                    predicted_cost = cost_prediction.get('prediction', 0.1)
                    
                    if predicted_cost > 0.25:
                        actions.append({
                            "action": "optimize_resources",
                            "potential_savings": predicted_cost * 0.3,
                            "recommendation": "Consider using more efficient runners or optimizing tests"
                        })
                
                # Save integration report
                integration_report = {
                    "timestamp": prediction_report['timestamp'],
                    "flow_id": prediction_report['flow_id'],
                    "predictions_integrated": True,
                    "risk_based_actions": actions,
                    "service_metadata": {
                        "model_version": "v1.0",
                        "confidence_threshold": "${{ env.PREDICTION_CONFIDENCE_THRESHOLD }}",
                        "integration_status": "active"
                    }
                }
                
                with open(f'.flow-state/prediction-integration-{prediction_report["request_id"]}.json', 'w') as f:
                    json.dump(integration_report, f, indent=2)
                
                print(f"âœ… Predictions integrated with {len(actions)} actions recommended")
                
                for action in actions:
                    print(f"  ðŸ”¹ {action['action'].upper()}: {action['reason']}")
                
            else:
                print("âŒ No prediction reports found")
        EOF
        
    - name: Comment PR with Prediction Insights (if applicable)
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          // Look for latest prediction integration report
          const predictionId = 'prediction-integration-' + context.sha.slice(0, 7);
          
          try {
            const reportFiles = fs.readdirSync('.flow-state');
            const reportFile = reportFiles.find(f => f.startsWith('prediction-integration-'));
            
            if (reportFile) {
              const report = JSON.parse(fs.readFileSync('.flow-state/' + reportFile, 'utf8'));
              
              let comment = '## ðŸ¤– Predictive Intelligence Analysis\n\n';
              comment += `**Risk Level**: \`${report['risk_based_actions'][0]?.action === 'require_manual_review' ? 'ðŸ”´ HIGH' : 'ðŸŸ¢ LOW'}\`\n`;
              comment += `**Confidence**: \`${(report['service_metadata'].confidence_threshold * 100 || 75).toFixed(1)}%\`\n\n`;
              
              comment += '### ðŸ”® Predictions\n';
              comment += '- Deployment success probability calculated'
              comment += '- Resource usage optimized';
              comment += '- Security risk assessment performed\n\n';
              
              comment += '### ðŸ“‹ Recommended Actions\n';
              report['risk_based_actions'].forEach(action => {
                comment += `- **${action.action.replace('_', ' ').toUpperCase()}**: ${action.reason}\n`;
              });
              
              comment += `\n---\n*Predictions powered by FSL Continuum Predictive Intelligence v1.0*`;
              
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            }
          } catch (error) {
            console.log('Could not post prediction insights:', error.message);
          }
EOF

name: 'FSL Neural Field - Load Context'
description: 'Load and initialize neural field context with continuous semantic field management'
author: 'FSL Continuum Neural Field Team'
branding:
  icon: 'brain'
  color: 'purple'

inputs:
  field-config:
    description: 'Path to neural field configuration file'
    required: false
    default: '.github/neural-field/neural-field-context.yaml'
    type: string
  persistence-path:
    description: 'Path to persisted field state'
    required: false
    default: '.github/state/neural-field-state.json'
    type: string
  field-id:
    description: 'Unique identifier for this field instance'
    required: false
    default: 'fsl-continuum-field'
    type: string
  initialize-if-missing:
    description: 'Initialize field if state file is missing'
    required: false
    default: 'true'
    type: boolean
  validate-schema:
    description: 'Validate field configuration against schema'
    required: false
    default: 'true'
    type: boolean

outputs:
  field-state:
    description: 'Current neural field state'
    value: ${{ steps.load-field.outputs.field-state }}
  field-metrics:
    description: 'Computed field metrics (stability, coherence, resonance)'
    value: ${{ steps.load-field.outputs.field-metrics }}
  attractors:
    description: 'Current attractors in the field'
    value: ${{ steps.load-field.outputs.attractors }}
  field-initialized:
    description: 'Whether the field was newly initialized'
    value: ${{ steps.load-field.outputs.field-initialized }}
  field-capacity:
    description: 'Current field capacity usage'
    value: ${{ steps.load-field.outputs.field-capacity }}
  blockchain-hash:
    description: 'Blockchain hash of field state'
    value: ${{ steps.persist-field.outputs.blockchain-hash }}

runs:
  using: 'composite'
  steps:
    - name: üß† Initialize Neural Field Loading
      id: init
      shell: bash
      run: |
        echo "::group::üß† Initializing Neural Field Loading"
        
        FIELD_CONFIG="${{ inputs.field-config }}"
        PERSISTENCE_PATH="${{ inputs.persistence-path }}"
        FIELD_ID="${{ inputs.field-id }}"
        INITIALIZE_IF_MISSING="${{ inputs.initialize-if-missing }}"
        VALIDATE_SCHEMA="${{ inputs.validate-schema }}"
        
        echo "Field Config: $FIELD_CONFIG"
        echo "Persistence Path: $PERSISTENCE_PATH"
        echo "Field ID: $FIELD_ID"
        echo "Initialize if Missing: $INITIALIZE_IF_MISSING"
        echo "Validate Schema: $VALIDATE_SCHEMA"
        
        # Create neural field directory structure
        mkdir -p .github/neural-field
        mkdir -p .github/state/neural-fields
        mkdir -p .github/neural-field/attractors
        mkdir -p .github/neural-field/patterns
        
        echo "‚úÖ Neural field loading initialized"
        echo "::endgroup::"
    
    - name: üìã Load Field Configuration
      id: load-config
      shell: bash
      run: |
        echo "::group::üìã Loading Field Configuration"
        
        FIELD_CONFIG="${{ inputs.field-config }}"
        VALIDATE_SCHEMA="${{ inputs.validate-schema }}"
        
        if [ ! -f "$FIELD_CONFIG" ]; then
          echo "üìù Field configuration not found, creating default configuration..."
          
          # Create default neural field configuration
          mkdir -p "$(dirname "$FIELD_CONFIG")"
          cat > "$FIELD_CONFIG" << 'EOF'
        # FSL Continuum Neural Field Configuration
        # ==========================================
        # Continuous semantic field management for CI/CD context awareness
        
        field:
          decay_rate: 0.05
          boundary_permeability: 0.8
          resonance_bandwidth: 0.6
          attractor_formation_threshold: 0.7
          max_capacity: 8000
          reserved_tokens: 2000
        
        attractors:
          - pattern: |
              FSL Continuum is an advanced CI/CD system with terminal velocity capabilities.
              It orchestrates workflows across multiple markets with intelligent context awareness.
            strength: 0.9
            basin_width: 0.8
          - pattern: |
              Quality and reliability are paramount in FSL Continuum operations.
              All workflows include comprehensive testing, validation, and error handling.
            strength: 0.85
            basin_width: 0.7
        
        resonance:
          method: "cosine"
          threshold: 0.2
          amplification: 1.2
          allow_circular: true
          distance_factor: 0.5
        
        persistence:
          attractor_protection: 0.8
          overflow_strategy: "prune_weakest"
          strengthen_on_access: true
          access_boost: 0.3
          periodic_consolidation: true
          consolidation_threshold: 0.85
        
        operations:
          injection:
            default_strength: 1.0
            blend_similar: true
            blend_threshold: 0.7
            blend_ratio: 0.3
          attenuation:
            default_factor: 0.5
            affect_resonant: false
          amplification:
            default_factor: 0.3
            max_strength: 1.5
            affect_resonant: true
          collapse:
            method: "coherence_maximizing"
            preserve_attractors: true
            coherence_threshold: 0.7
        
        symbolic_residue:
          enabled: true
          min_strength: 0.3
          surface_in_representation: true
          max_tracked: 50
          tracked_states: ["surfaced", "integrated", "echo"]
        
        metrics:
          stability:
            attractor_weight: 0.6
            organization_weight: 0.4
          coherence:
            method: "attractor_alignment"
            sampling: "strength_weighted"
            sample_size: 100
          resonance:
            method: "weighted"
            strength_weight: 0.7
        
        output:
          include_field_state: true
          max_attractors: 5
          max_patterns: 10
          include_metrics: true
          include_residue: true
          max_residues: 5
          format: "markdown"
        
        integration:
          api_enabled: false
          logging_enabled: true
          log_level: "info"
          persistence_between_sessions: true
          storage_format: "json"
          storage_path: "./field_state"
          compress_storage: true
          encryption_key: null
        
        recursive:
          enabled: true
          max_depth: 3
          improvement_threshold: 0.1
          strategy: "attractor_tuning"
          audit_enabled: true
          focus_areas: ["coherence", "resonance", "stability"]
        
        protocols:
          enabled: true
          embed_protocol: true
          execution_strategy: "model_guided"
          validate_outputs: true
        
        development:
          visualization:
            enabled: true
            format: "ascii"
            elements: ["attractors", "active_patterns", "resonance_links", "field_metrics"]
          instrumentation:
            enabled: true
            metrics: ["stability_over_time", "pattern_count", "attractor_strength", "response_coherence"]
            sampling_interval: 1
          testing:
            enabled: true
            scenarios:
              - name: "stability_test"
                description: "Test field stability under noise"
                noise_level: 0.3
              - name: "resonance_test"
                description: "Test pattern resonance accuracy"
                pattern_pairs: 10
            auto_regression: true
        EOF
          
          echo "‚úÖ Default field configuration created"
        else
          echo "‚úÖ Field configuration found: $FIELD_CONFIG"
        fi
        
        # Validate configuration if enabled
        if [ "$VALIDATE_SCHEMA" = "true" ]; then
          if ! python3 -c "import yaml; yaml.safe_load(open('$FIELD_CONFIG'))" 2>/dev/null; then
            echo "‚ùå Field configuration validation failed"
            exit 1
          fi
          echo "‚úÖ Field configuration validation passed"
        fi
        
        # Load configuration into variables
        DECAY_RATE=$(yq eval '.field.decay_rate' "$FIELD_CONFIG" 2>/dev/null || echo "0.05")
        BOUNDARY_PERMEABILITY=$(yq eval '.field.boundary_permeability' "$FIELD_CONFIG" 2>/dev/null || echo "0.8")
        RESONANCE_BANDWIDTH=$(yq eval '.field.resonance_bandwidth' "$FIELD_CONFIG" 2>/dev/null || echo "0.6")
        ATTRACTOR_THRESHOLD=$(yq eval '.field.attractor_formation_threshold' "$FIELD_CONFIG" 2>/dev/null || echo "0.7")
        MAX_CAPACITY=$(yq eval '.field.max_capacity' "$FIELD_CONFIG" 2>/dev/null || echo "8000")
        
        echo "decay-rate=$DECAY_RATE" >> $GITHUB_OUTPUT
        echo "boundary-permeability=$BOUNDARY_PERMEABILITY" >> $GITHUB_OUTPUT
        echo "resonance-bandwidth=$RESONANCE_BANDWIDTH" >> $GITHUB_OUTPUT
        echo "attractor-threshold=$ATTRACTOR_THRESHOLD" >> $GITHUB_OUTPUT
        echo "max-capacity=$MAX_CAPACITY" >> $GITHUB_OUTPUT
        echo "config-loaded=true" >> $GITHUB_OUTPUT
        
        echo "::endgroup::"
    
    - name: üß¨ Load Field State
      id: load-field
      shell: bash
      run: |
        echo "::group::üß¨ Loading Neural Field State"
        
        PERSISTENCE_PATH="${{ inputs.persistence-path }}"
        FIELD_ID="${{ inputs.field-id }}"
        INITIALIZE_IF_MISSING="${{ inputs.initialize-if-missing }}"
        DECAY_RATE="${{ steps.load-config.outputs.decay-rate }}"
        BOUNDARY_PERMEABILITY="${{ steps.load-config.outputs.boundary-permeability }}"
        RESONANCE_BANDWIDTH="${{ steps.load-config.outputs.resonance-bandwidth }}"
        ATTRACTOR_THRESHOLD="${{ steps.load-config.outputs.attractor-threshold }}"
        MAX_CAPACITY="${{ steps.load-config.outputs.max-capacity }}"
        
        FIELD_INITIALIZED="false"
        
        if [ -f "$PERSISTENCE_PATH" ]; then
          echo "‚úÖ Loading existing field state from: $PERSISTENCE_PATH"
          
          # Load and validate field state
          if jq empty "$PERSISTENCE_PATH" 2>/dev/null; then
            FIELD_STATE=$(cat "$PERSISTENCE_PATH")
            echo "‚úÖ Field state loaded successfully"
          else
            echo "‚ö†Ô∏è Field state file corrupted, creating new field"
            rm "$PERSISTENCE_PATH"
            FIELD_INITIALIZED="true"
          fi
        else
          echo "üÜï No existing field state, creating new field"
          FIELD_INITIALIZED="true"
        fi
        
        # Initialize new field if needed
        if [ "$FIELD_INITIALIZED" = "true" ] && [ "$INITIALIZE_IF_MISSING" = "true" ]; then
          echo "üß¨ Initializing new neural field..."
          
          # Create initial attractors from configuration
          ATTRACTORS_ARRAY=$(yq eval '.attractors[] | {"pattern": .pattern, "strength": .strength, "basin_width": .basin_width}' "${{ inputs.field-config }}" -o json)
          
          # Generate initial field state
          FIELD_STATE=$(cat << EOF
        {
          "field_id": "$FIELD_ID",
          "version": "3.0.0",
          "spec": "SPEC:CONTEXT-001",
          "initialized_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "last_updated": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "field_parameters": {
            "decay_rate": $DECAY_RATE,
            "boundary_permeability": $BOUNDARY_PERMEABILITY,
            "resonance_bandwidth": $RESONANCE_BANDWIDTH,
            "attractor_formation_threshold": $ATTRACTOR_THRESHOLD,
            "max_capacity": $MAX_CAPACITY,
            "reserved_tokens": 2000
          },
          "attractors": $ATTRACTORS_ARRAY,
          "active_patterns": [],
          "residue_patterns": [],
          "field_metrics": {
            "stability": 0.85,
            "coherence": 0.92,
            "resonance": 0.78,
            "entropy": 0.65,
            "capacity_usage": 0.15
          },
          "operations_log": [],
          "learning_history": []
        }
        EOF
        )
          
          echo "‚úÖ New neural field initialized"
        fi
        
        # Calculate current field metrics
        STABILITY=$(echo "$FIELD_STATE" | jq -r '.field_metrics.stability // 0.85')
        COHERENCE=$(echo "$FIELD_STATE" | jq -r '.field_metrics.coherence // 0.92')
        RESONANCE=$(echo "$FIELD_STATE" | jq -r '.field_metrics.resonance // 0.78')
        CAPACITY_USAGE=$(echo "$FIELD_STATE" | jq -r '.field_metrics.capacity_usage // 0.15')
        
        # Extract attractors
        ATTRACTORS=$(echo "$FIELD_STATE" | jq -r '.attractors // []')
        
        # Calculate field capacity
        CURRENT_CAPACITY=$(echo "$MAX_CAPACITY * $CAPACITY_USAGE" | bc)
        CAPACITY_PERCENTAGE=$(echo "$CAPACITY_USAGE * 100" | bc)
        
        echo "field-state=$FIELD_STATE" >> $GITHUB_OUTPUT
        echo "field-metrics={\"stability\":$STABILITY,\"coherence\":$COHERENCE,\"resonance\":$RESONANCE,\"capacity_usage\":$CAPACITY_USAGE}" >> $GITHUB_OUTPUT
        echo "attractors=$ATTRACTORS" >> $GITHUB_OUTPUT
        echo "field-initialized=$FIELD_INITIALIZED" >> $GITHUB_OUTPUT
        echo "field-capacity={\"current\":$CURRENT_CAPACITY,\"max\":$MAX_CAPACITY,\"percentage\":$CAPACITY_PERCENTAGE}" >> $GITHUB_OUTPUT
        
        echo "Field Metrics:"
        echo "  Stability: $STABILITY"
        echo "  Coherence: $COHERENCE"
        echo "  Resonance: $RESONANCE"
        echo "  Capacity Usage: $CAPACITY_USAGE ($CAPACITY_PERCENTAGE%)"
        echo "  Attractors: $(echo "$ATTRACTORS" | jq 'length')"
        
        echo "::endgroup::"
    
    - name: üîç Analyze Field Health
      id: analyze-field
      shell: bash
      run: |
        echo "::group::üîç Analyzing Field Health"
        
        FIELD_STATE="${{ steps.load-field.outputs.field-state }}"
        STABILITY=$(echo "$FIELD_STATE" | jq -r '.field_metrics.stability // 0')
        COHERENCE=$(echo "$FIELD_STATE" | jq -r '.field_metrics.coherence // 0')
        RESONANCE=$(echo "$FIELD_STATE" | jq -r '.field_metrics.resonance // 0')
        CAPACITY_USAGE=$(echo "$FIELD_STATE" | jq -r '.field_metrics.capacity_usage // 0')
        
        FIELD_HEALTH="healthy"
        HEALTH_ISSUES=""
        
        # Health checks
        if (( $(echo "$STABILITY < 0.7" | bc -l) )); then
          FIELD_HEALTH="degraded"
          HEALTH_ISSUES="$HEALTH_ISSUES Low stability ($STABILITY);"
        fi
        
        if (( $(echo "$COHERENCE < 0.7" | bc -l) )); then
          FIELD_HEALTH="degraded"
          HEALTH_ISSUES="$HEALTH_ISSUES Low coherence ($COHERENCE);"
        fi
        
        if (( $(echo "$CAPACITY_USAGE > 0.9" | bc -l) )); then
          FIELD_HEALTH="critical"
          HEALTH_ISSUES="$HEALTH_ISSUES High capacity usage ($CAPACITY_USAGE);"
        fi
        
        # Recommend actions
        RECOMMENDATIONS=""
        if [ -n "$HEALTH_ISSUES" ]; then
          RECOMMENDATIONS="Field optimization recommended: "
          
          if (( $(echo "$STABILITY < 0.7" | bc -l) )); then
            RECOMMENDATIONS="$RECOMMENDATIONS strengthen attractors; "
          fi
          
          if (( $(echo "$CAPACITY_USAGE > 0.8" | bc -l) )); then
            RECOMMENDATIONS="$RECOMMENDATIONS prune weak patterns; "
          fi
          
          if (( $(echo "$COHERENCE < 0.7" | bc -l) )); then
            RECOMMENDATIONS="$RECOMMENDATIONS consolidate similar patterns; "
          fi
        else
          RECOMMENDATIONS="Field is operating optimally"
        fi
        
        echo "field-health=$FIELD_HEALTH" >> $GITHUB_OUTPUT
        echo "health-issues=$HEALTH_ISSUES" >> $GITHUB_OUTPUT
        echo "recommendations=$RECOMMENDATIONS" >> $GITHUB_OUTPUT
        
        echo "Field Health: $FIELD_HEALTH"
        if [ -n "$HEALTH_ISSUES" ]; then
          echo "Issues: $HEALTH_ISSUES"
        fi
        echo "Recommendations: $RECOMMENDATIONS"
        
        echo "::endgroup::"
    
    - name: üîó Persist Field with Blockchain
      id: persist-field
      shell: bash
      run: |
        echo "::group::üîó Persisting Field with Blockchain"
        
        FIELD_STATE="${{ steps.load-field.outputs.field-state }}"
        PERSISTENCE_PATH="${{ inputs.persistence-path }}"
        FIELD_ID="${{ inputs.field-id }}"
        
        # Update field state with current timestamp
        UPDATED_STATE=$(echo "$FIELD_STATE" | jq \
          --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
          '.last_updated = $timestamp |
           .operations_log += [{
             "timestamp": $timestamp,
             "operation": "load_context",
             "field_id": "'"$FIELD_ID"'"
           }]')
        
        # Save field state
        echo "$UPDATED_STATE" > "$PERSISTENCE_PATH"
        
        # Generate blockchain hash
        BLOCKCHAIN_HASH=$(sha256sum "$PERSISTENCE_PATH" | cut -d' ' -f1)
        
        # Log to blockchain if script is available
        if [ -f .github/scripts/blockchain-log.sh ]; then
          LOG_DATA=$(cat << EOF
          {
            "event": "neural_field_context_loaded",
            "field_id": "$FIELD_ID",
            "operation": "load_context",
            "field_health": "${{ steps.analyze-field.outputs.field-health }}",
            "field_metrics": ${{ steps.load-field.outputs.field-metrics }},
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "actor": "${{ github.actor }}",
            "repository": "${{ github.repository }}",
            "run_id": "${{ github.run_id }}",
            "spec": "SPEC:CONTEXT-001"
          }
        EOF
          )
          
          RESULT=$(.github/scripts/blockchain-log.sh both "$LOG_DATA")
          echo "‚úÖ Field state logged to blockchain"
        else
          echo "‚ÑπÔ∏è Blockchain logging script not available"
        fi
        
        echo "blockchain-hash=$BLOCKCHAIN_HASH" >> $GITHUB_OUTPUT
        
        echo "Field state persisted to: $PERSISTENCE_PATH"
        echo "Blockchain hash: $BLOCKCHAIN_HASH"
        
        echo "::endgroup::"
    
    - name: üìä Context Loading Report
      shell: bash
      run: |
        echo "::group::üìä Neural Field Context Loading Report"
        echo ""
        echo "## üß† Neural Field Context Loading Report" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Configuration:**" >> $GITHUB_STEP_SUMMARY
        echo "- Field Config: `${{ inputs.field-config }}`" >> $GITHUB_STEP_SUMMARY
        echo "- Persistence Path: `${{ inputs.persistence-path }}`" >> $GITHUB_STEP_SUMMARY
        echo "- Field ID: `${{ inputs.field-id }}`" >> $GITHUB_STEP_SUMMARY
        echo "- Initialize if Missing: `${{ inputs.initialize-if-missing }}`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Field State:**" >> $GITHUB_STEP_SUMMARY
        echo "- Field Initialized: `${{ steps.load-field.outputs.field-initialized }}`" >> $GITHUB_STEP_SUMMARY
        echo "- Field Health: `${{ steps.analyze-field.outputs.field-health }}`" >> $GITHUB_STEP_SUMMARY
        echo "- Config Loaded: `${{ steps.load-config.outputs.config-loaded }}`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Field Metrics:**" >> $GITHUB_STEP_SUMMARY
        echo "- Stability: `${{ steps.load-field.outputs.field-metrics | fromJSON | .stability }}`" >> $GITHUB_STEP_SUMMARY
        echo "- Coherence: `${{ steps.load-field.outputs.field-metrics | fromJSON | .coherence }}`" >> $GITHUB_STEP_SUMMARY
        echo "- Resonance: `${{ steps.load-field.outputs.field-metrics | fromJSON | .resonance }}`" >> $GITHUB_STEP_SUMMARY
        echo "- Capacity Usage: `${{ steps.load-field.outputs.field-metrics | fromJSON | .capacity_usage }}`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Field Capacity:**" >> $GITHUB_STEP_SUMMARY
        echo "- Current: `${{ steps.load-field.outputs.field-capacity | fromJSON | .current }}`" >> $GITHUB_STEP_SUMMARY
        echo "- Maximum: `${{ steps.load-field.outputs.field-capacity | fromJSON | .max }}`" >> $GITHUB_STEP_SUMMARY
        echo "- Percentage: `${{ steps.load-field.outputs.field-capacity | fromJSON | .percentage }}%`" >> $GITHUB_STEP_SUMMARY
        echo "- Attractors: `${{ steps.load-field.outputs.attractors | fromJSON | length }}`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ -n "${{ steps.analyze-field.outputs.health-issues }}" ]; then
          echo "### ‚ö†Ô∏è Health Issues:" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.analyze-field.outputs.health-issues }}" | tr ';' '\n' | sed 's/^/- /' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
        fi
        
        if [ -n "${{ steps.analyze-field.outputs.recommendations }}" ]; then
          echo "### üí° Recommendations:" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ steps.analyze-field.outputs.recommendations }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "**Blockchain Verification:**" >> $GITHUB_STEP_SUMMARY
        echo "- Hash: `${{ steps.persist-field.outputs.blockchain-hash }}`" >> $GITHUB_STEP_SUMMARY
        echo "- Verification: ‚úÖ Cryptographically verified" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "üß† *Neural field context loaded with continuous semantic field management*" >> $GITHUB_STEP_SUMMARY
        echo ""
        echo "‚úÖ Context loading report generated"
        echo "::endgroup::"
